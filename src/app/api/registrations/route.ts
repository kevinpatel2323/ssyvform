import { NextResponse } from "next/server";
import { query } from "@/lib/db";
import { uploadFile } from "@/lib/storage";

export const runtime = "nodejs";

function requiredString(formData: FormData, key: string) {
  const value = formData.get(key);
  if (typeof value !== "string" || value.trim().length === 0) {
    throw new Error(`Missing field: ${key}`);
  }
  return value.trim();
}

function capitalizeFirstLetter(str: string): string {
  if (!str) return str;
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

export async function POST(request: Request) {
  try {
    const formData = await request.formData();

    // Get name fields and capitalize first letter
    // Note: serial_number will be auto-generated by database trigger
    const firstName = capitalizeFirstLetter(requiredString(formData, "firstName"));
    const middleName = capitalizeFirstLetter(requiredString(formData, "middleName"));
    const lastName = capitalizeFirstLetter(requiredString(formData, "lastName"));
    const gender = requiredString(formData, "gender");

    if (gender !== "male" && gender !== "female") {
      return NextResponse.json(
        { error: "Invalid gender value" },
        { status: 400 }
      );
    }

    const maritalStatus = requiredString(formData, "maritalStatus");
    if (maritalStatus !== "married" && maritalStatus !== "unmarried") {
      return NextResponse.json(
        { error: "Invalid marital status value" },
        { status: 400 }
      );
    }

    const birthday = requiredString(formData, "birthday");
    const street = requiredString(formData, "street");
    const city = requiredString(formData, "city");
    const state = requiredString(formData, "state");
    const zipCode = requiredString(formData, "zipCode");
    const phone = requiredString(formData, "phone");
    const nativePlace = requiredString(formData, "nativePlace");

    // Get conditional phone field for females
    const relativePhone = formData.get("relativePhone");
    
    // Save custom city, state, and native place to database if they don't exist
    const saveCustomOption = async (type: "cities" | "states" | "native_places", name: string) => {
      try {
        const trimmedName = name.trim();
        if (!trimmedName) return;
        
        // Try to insert the new option
        await query<{ name: string }>(
          `INSERT INTO ${type} (name) VALUES ($1)`,
          [trimmedName]
        );
      } catch (err: any) {
        // If it's a unique constraint violation, the option already exists - that's fine
        // For any other error, silently fail - not critical if saving fails
        if (err.code !== "23505") {
          console.error(`Failed to save custom ${type}:`, err);
        }
      }
    };
    
    // Save custom entries to database
    await Promise.all([
      saveCustomOption("cities", city),
      saveCustomOption("states", state),
      saveCustomOption("native_places", nativePlace),
    ]);

    const photo = formData.get("photo");
    if (!(photo instanceof File)) {
      return NextResponse.json(
        { error: "Photo is required" },
        { status: 400 }
      );
    }

    const bucket = process.env.GCS_PHOTOS_BUCKET ?? "registration-photos";
    const table = process.env.REGISTRATIONS_TABLE ?? "registrations";

    const extension = photo.name.includes(".")
      ? photo.name.split(".").pop()
      : "jpg";

    const photoPath = `${crypto.randomUUID()}.${extension}`;

    try {
      await uploadFile(
        bucket,
        photoPath,
        photo,
        photo.type || "application/octet-stream"
      );
    } catch (uploadError) {
      const errorMessage = uploadError instanceof Error ? uploadError.message : "Failed to upload photo";
      console.error("Photo upload error:", errorMessage);
      return NextResponse.json(
        { error: errorMessage },
        { status: 500 }
      );
    }

    // Build insert object with new name fields
    // Note: You must run the migration (update_registrations_name_fields.sql) first
    // to add the first_name, middle_name, and last_name columns to your database
    // Note: serial_number will be auto-generated by database trigger
    const insertData: Record<string, any> = {
      first_name: firstName,
      middle_name: middleName,
      last_name: lastName,
      gender,
      marital_status: maritalStatus,
      birthday,
      street,
      city,
      state,
      zip_code: zipCode,
      phone,
      native_place: nativePlace,
      photo_bucket: bucket,
      photo_path: photoPath,
    };

    // Add conditional phone field for females
    if (gender === "female") {
      if (typeof relativePhone === "string" && relativePhone.trim()) {
        insertData.relative_phone = relativePhone.trim();
      }
    }

    const columns = Object.keys(insertData);
    const values = Object.values(insertData);
    const placeholders = values.map((_, i) => `$${i + 1}`).join(', ');
    const columnNames = columns.join(', ');

    const result = await query<{ id: string; serial_number: string }>(
      `INSERT INTO ${table} (${columnNames}) VALUES (${placeholders}) RETURNING id, serial_number`,
      values
    );

    if (result.rows.length === 0) {
      return NextResponse.json(
        { error: "Failed to create registration" },
        { status: 500 }
      );
    }

    return NextResponse.json({ 
      ok: true, 
      id: result.rows[0].id,
      serialNumber: result.rows[0].serial_number 
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : "Unknown error";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
